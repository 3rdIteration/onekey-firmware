syntax = "proto2";
package hw.trezor.messages.special;

// Sugar for easier handling in Java
option java_package = "com.satoshilabs.trezor.lib.protobuf";
option java_outer_classname = "TrezorMessageSpecial";

/**
 * Request: Ask device to sign a hex digest
 * @start
 * @next DigestSignature
 * @next Failure
 */
message SignDigest {
    repeated uint32 address_n = 1;                                      // BIP-32 path to derive the key from master node
    optional bytes digest = 2;                                          // digest to be signed
    optional string coin_name = 3 [default='Bitcoin'];                  // coin to use for signing
}

/**
 * Response: Signed hex signature
 * @end
 */
message DigestSignature {
    required bytes pubkey = 1;      // public key used for signing
    optional bytes signature = 2;   // signature of the hex digest
}


/**
 * Request: Ask device to sign raw data, using sha256 as the hash function
 * @start
 * @next DataSignature
 * @next Failure
 */
message SignData {
    repeated uint32 address_n = 1;                                      // BIP-32 path to derive the key from master node
    optional bytes data = 2;                                            // data to be signed
    optional string coin_name = 3 [default='Bitcoin'];                  // coin to use for signing
}

/**
 * Response: Signed data signature
 * @end
 */
message DataSignature {
    required bytes pubkey = 1;      // public key used for signing
    optional bytes digest = 2;      // digest of the raw data, using sha256 as the hash function
    optional bytes signature = 3;   // signature of the raw data
}


/**
 * Request: Ask device to export an ed25519 public key
 * @start
 * @next Ed25519PublicKey
 * @next Failure
 */
message ExportEd25519PublicKey {
    repeated uint32 address_n = 1;                                      // BIP-32 path to derive the key from master node
}

/**
 * Response: The ed25519 public key
 * @end
 */
message Ed25519PublicKey {
    required bytes pubkey = 1;      // public key for signing
    required bytes privkey = 2;     // private key, only for testing, DO NOT use in production
}


/**
 * Request: Ask device to calculate the determinstic nonce of an ed25519 key
 * @start
 * @next Ed25519Nonce
 * @next Failure
 */
message GetEd25519Nonce {
    repeated uint32 address_n = 1;      // BIP-32 path to derive the key from master node
    required bytes data = 2;            // data to be get involved in the nonce
    required uint32 ctr = 3;            // the sequence number of the key
}

/**
 * Response: The determinstic nonce
 * @end
 */
message Ed25519Nonce {
    required bytes R = 1;      // R of the nonce
    required bytes r = 2;      // r of the nonce, only for test, DO NOT use in production
    required bytes r_src = 3;      // the source of r, r = H(r_src), only for test, DO NOT use in production
}


/**
 * Request: Sign a digest by using ed25519 cosign approach
 * @start
 * @next Ed25519Signature
 * @next Failure
 */
message CosignEd25519 {
    repeated uint32 address_n = 1;      // BIP-32 path to derive the key from master node
    required bytes digest = 2;          // data to be get involved in the nonce
    required uint32 ctr = 3;            // the sequence number of the key to get the r value of nonce
    required bytes global_pubkey = 4;   // global public combined from the participants' public keys
    required bytes global_commit = 5;   // global commitment combined from the participants' R value of nonce
}

/**
 * Response: The signature of ed25519
 * @end
 */
message Ed25519Signature {
    required bytes sig = 1;      // signature
    required bytes r = 2;
    required bytes s1 = 3;
}

/**
 * Request: Verify an ed25519 signature
 * @start
 * @next Success
 * @next Failure
 */
message Ed25519Verify {
    required bytes digest = 1;
    required bytes pubkey = 2;
    required bytes sig = 3;
}
